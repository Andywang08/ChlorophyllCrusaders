---
title: "R Notebook"
output: html_notebook
---
Our forecast requires 3 steps: 
1) grabbing the forecasted temperature data
2) grabbing previous gcc data and training a model on this data to get betas
3) using forecast data, the previous model, and the calculated betas, have the model output data for the future. 


## Step 1: Grabbing the Forecast Temperature Data
```{r}
#get forecast data
noaa_mean_forecast <- function(site, var, reference_date) {
  endpoint = "data.ecoforecast.org"
  bucket <- glue::glue("neon4cast-drivers/noaa/gefs-v12/stage1/0/{reference_date}")
  s3 <- arrow::s3_bucket(bucket, endpoint_override = endpoint, anonymous = TRUE)
  
  # stage1 air temp is Celsius
  arrow::open_dataset(s3) |>
    dplyr::filter(site_id == site,
                  datetime >= lubridate::as_datetime(reference_date),
                  variable == var) |>
    dplyr::select(datetime, prediction, parameter) |>
    dplyr::mutate(datetime = as_date(datetime)) |>
    dplyr::group_by(datetime, parameter) |>
    dplyr::summarize(air_temperature = mean(prediction), .groups = "drop") |>
    dplyr::select(datetime, air_temperature, parameter) |>
    dplyr::rename(ensemble = parameter) |>
    dplyr::collect()
}
site = 'HARV'
date = "2024-02-05"
TMP_future <- noaa_mean_forecast(site, "TMP", date)
```


## Step 2: Grabbing Previous GCC Data and Training a Model on this Data to get Betas
```{r}
remotes::install_github("eco4cast/neon4cast", force=TRUE)
devtools::install_github("EcoForecast/ecoforecastR",force=TRUE)
library(dplyr)
library(rjags)
URL = "https://data.ecoforecast.org/neon4cast-targets/phenology/phenology-targets.csv.gz"

# Get gcc data
data = readr::read_csv(URL, col_names = c("Date", "Siteid", "Variable", "Observation"))
harv = na.omit(data[data$Siteid == "HARV",]) # filter by Harvard Forest site
# time = as.Date(harv$Date)

gcc_90 = harv[harv$Variable == "gcc_90",]
#rcc_90 = harv[harv$Variable == "rcc_90",]

#save(gcc_90, file="gcc.Rdata")
```

```{r}
# Get weather data :: Only up to current date, not forecast
weather_stage3 <- neon4cast::noaa_stage3()
ds1 <- weather_stage3 |> 
  dplyr::filter(site_id == "HARV") |>
  dplyr::collect()

TMP = ds1[ds1$variable == "air_temperature",]

# clean up temp data
tmps <- as.data.frame(TMP) # save temperature data as dataframe
temp_max <- tmps %>% 
  group_by(datetime) %>%
  summarize(temp.max = max(prediction))

# Add date column
temp_max$date <- temp_max$datetime
temp_max$date <- as.character(temp_max$date) # necessary for merging

# Get one value of a mean of a temperature ensemble per day
temp_means <- temp_max %>% 
  group_by(date) %>%
  summarize(temp.mean = mean(temp.max))

# Convert to Celsius
temp_means$temp.mean <- temp_means$temp.mean - 273.15

# Subset the data to the available temperature data ?
data1 <- gcc_90[which(gcc_90$Date == temp_means$date[1]):nrow(gcc_90), ]
temp <- temp_means[temp_means$date %in% data1$Date, ]

# Add temperature as column in data dataframe
data1$Temperature <- temp$temp.mean

###### ^ collapses the ensembles into one temperature value per day; 
###### For milestone 6, we should not do this and make forecasts for each ensemble 

time = as.Date(data1$Date) # get vector of time steps

# run a DLM with temperature as a covariate for gcc
gcc.out <- ecoforecastR::fit_dlm(model=list(obs="Observation", fixed="~ 1 + X + Temperature"), data1)
# names(gcc.out)

params <- window(gcc.out$params, start=1000) ## remove burn-in

# For diagnostic purposes
#plot(params)
#summary(params)
#cor(as.matrix(params))
#pairs(as.matrix(params))

# Plot the model confidence intervals and the original data points: success!
out <- as.matrix(gcc.out$predict) # get model predictions
ci <- apply(out, 2, quantile, c(0.025,0.5,0.975)) # get model confidence intervals
plot(time, ci[2,], type='n', ylab="GCC_90", xlab="Time") # create empty plot with proper axes
## adjust x-axis label to be monthly if zoomed
#if(diff(time.rng) < 100){ 
#  axis.Date(1, at=seq(time[time.rng[1]],time[time.rng[2]],by='month'), format = "%Y-%m")
#}
ecoforecastR::ciEnvelope(time,ci[1,],ci[3,],col=ecoforecastR::col.alpha("lightBlue",0.75)) # add 25% and 75% confidence intervals
points(time, data1$Observation, pch="+",cex=0.5) # plot gcc_90 original points

# save(gcc.out, file="DLM.Rdata") # uncomment out once for saving this historical forecast

## To access the betas/ anything else generated by this DLM, you can use the following:
# params <- gcc.out$params

## Model predictions for gcc
# out <- as.matrix(gcc.out$predict)

## Model confidence intervals
# ci <- apply(out, 2, quantile, c(0.025,0.5,0.975)) # get model confidence intervals

## Data
# data <- gcc.out$data
```


## Step 3: Use Forecast Data,  Previous Model, and Calculated Betas to make Forecast

```{r}
# Define a function to forecast future values
forecast_future <- function(model, beta, temperature_future, time_future) {
  # Generate design matrix for future data
  X_future <- cbind(1, temperature_future)

  X_future_matrix <- as.matrix(X_future[, c(1, 3)])
  beta_matrix <- t(as.matrix(params[[1]][, c(1, 2)]))

  # Perform matrix multiplication
  predicted <- X_future_matrix %*% beta_matrix
  
  # Return a data frame with time and predicted values
  data.frame(Time = time_future, Forecast = predicted)
}

#split TMP_future by ensemble and produce forecast per ensemble
for (i in 1:30) 
  {
    # utilize temperture forecase data from step 1
    filtered_temperature_future <- subset(TMP_future, ensemble == i)
    
    # Example: Forecast future values for the next 30 days
    future_days <- 36#nrow(filtered_temperature_future)
    print(length(future_days))
    last_date <- tail(as.Date(data1$Date), 1)
    time_future <- seq(last_date + 1, length.out = future_days, by = "day")
                
    # Forecast future values using the defined function
    forecast <- forecast_future(model = gcc.out, beta = params[[2]], temperature_future = filtered_temperature_future, time_future = time_future)
                
    #Plot the forecasted values along with the observed data
    plot(forecast$Time, forecast$Forecast.2, col = "red", lty = 2, type = 'b', xlab = "Date", ylab = "Temperature (CÂ°)")
    
  }


```
