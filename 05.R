remotes::install_github("eco4cast/neon4cast", force=TRUE)
devtools::install_github("EcoForecast/ecoforecastR",force=TRUE)
library(dplyr)
library(rjags)
URL = "https://data.ecoforecast.org/neon4cast-targets/phenology/phenology-targets.csv.gz"

# Get gcc data
data = readr::read_csv(URL, col_names = c("Date", "Siteid", "Variable", "Observation"))
harv = na.omit(data[data$Siteid == "HARV",]) # filter by Harvard Forest site
# time = as.Date(harv$Date)

gcc_90 = harv[harv$Variable == "gcc_90",]
#rcc_90 = harv[harv$Variable == "rcc_90",]

#save(gcc_90, file="gcc.Rdata")

# Get weather data :: Only up to current date, not forecast
weather_stage3 <- neon4cast::noaa_stage3()
ds1 <- weather_stage3 |> 
  dplyr::filter(site_id == "HARV") |>
  dplyr::collect()

TMP = ds1[ds1$variable == "air_temperature",]

# clean up temp data
tmps <- as.data.frame(TMP) # save temperature data as dataframe
temp_max <- tmps %>% 
  group_by(datetime) %>%
  summarize(temp.max = max(prediction))

# Add date column
temp_max$date <- date(temp_max$datetime)
temp_max$date <- as.character(temp_max$date) # necessary for merging

# Get one value of a mean of a temperature ensemble per day
temp_means <- temp_max %>% 
  group_by(date) %>%
  summarize(temp.mean = mean(temp.max))

# Convert to Celsius
# temp_means$temp.mean <- lapply(temp_means$temp.mean, k.to.c)

# Subset the data to the available temperature data ?
data1 <- gcc_90[which(gcc_90$Date == temp_means$date[1]):nrow(gcc_90), ]
temp <- temp_means[temp_means$date %in% data1$Date, ]

# Add temperature as column in data dataframe
data1$Temperature <- temp$temp.mean

###### ^ collapses the ensembles into one temperature value per day; 
###### For milestone 6, we should not do this and make forecasts for each ensemble 

time = as.Date(data1$Date) # get vector of time steps

# run a DLM with temperature as a covariate for gcc
gcc.out <- ecoforecastR::fit_dlm(model=list(obs="Observation", fixed="~ 1 + X + Temperature"), data1)
# names(gcc.out)

params <- window(gcc.out$params, start=1000) ## remove burn-in

# For diagnostic purposes
#plot(params)
#summary(params)
#cor(as.matrix(params))
#pairs(as.matrix(params))

# Plot the model confidence intervals and the original data points: success!
out <- as.matrix(gcc.out$predict) # get model predictions
ci <- apply(out, 2, quantile, c(0.025,0.5,0.975)) # get model confidence intervals
plot(time, ci[2,], type='n', ylab="GCC_90", xlab="Time") # create empty plot with proper axes
## adjust x-axis label to be monthly if zoomed
#if(diff(time.rng) < 100){ 
#  axis.Date(1, at=seq(time[time.rng[1]],time[time.rng[2]],by='month'), format = "%Y-%m")
#}
ecoforecastR::ciEnvelope(time,ci[1,],ci[3,],col=ecoforecastR::col.alpha("lightBlue",0.75)) # add 25% and 75% confidence intervals
points(time, data1$Observation, pch="+",cex=0.5) # plot gcc_90 original points

# save(gcc.out, file="DLM.Rdata") # uncomment out once for saving this historical forecast

## To access the betas/ anything else generated by this DLM, you can use the following:
# params <- gcc.out$params

## Model predictions for gcc
# out <- as.matrix(gcc.out$predict)

## Model confidence intervals
# ci <- apply(out, 2, quantile, c(0.025,0.5,0.975)) # get model confidence intervals

## Data
# data <- gcc.out$data

